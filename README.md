### 基于 STM32+FreeRTOS 的物联网环境监测与 OTA 远程升级系统设计报告

 **1. 项目背景与演进** 
本项目是在原有的本地环境监测系统（Gitee 仓库: yy0624/free-rtos）基础上进行的架构重构与功能升级。
v1.0 (原版)：基于 FreeRTOS 的单体应用。实现了 DHT11、BH1750 数据采集与 OLED 显示，仅具备本地监测功能，缺乏远程维护能力。v2.0 (升级版)：引入 Bootloader + APP 双分区架构。增加了 ESP32 Wi-Fi 通信模块，接入 OneNET 物联网平台，实现了数据的云端上报和 FOTA (Firmware Over-The-Air) 远程固件全量升级。

 **2. 系统架构** 

2.1 硬件方案
| 主控:  | STM32F407ZGT6                     |
|------|-----------------------------------|
| 通信   | ESP8266/ESP32 (UART2, 波特率 115200) |
| 传感器: | DHT11 (温湿度), BH1750 (光照)          |
| 交互:  | 0.96寸 OLED (I2C)                  |



2.2 软件架构 (FreeRTOS 多任务)任务名称优先级职责描述
| 任务名称        | 优先级    | 职责描述                                                                  |
|-------------|--------|-----------------------------------------------------------------------|
| SensorTask  | High   | 读取传感器数据（互斥锁保护 I2C），确保采样时序稳定。                                          |
| DisplayTask | Low    | 负责 UI 刷新，从全局变量获取数据，避免阻塞通信。                                            |
| CommTask    | Normal | 核心任务。平时负责 MQTT 数据上报；在接收到 OTA 指令后，挂起其他任务，转为 DMA 接收模式，执行固件下载与 Flash 写入。 |


 **3. 核心技术难点与解决方案复盘 (重点** )
在从 v1.0 向 v2.0 迁移的过程中，我遇到了四个主要的技术阻塞点。以下是详细的排查过程与最终解决方案：

 **难点一：OneNET 平台多版本文档冲突与 OTA 协议适配** 

 **问题描述：** 
在开发初期，ESP 模组无法正确获取 OTA 升级任务。主要原因是 OneNET 平台存在“多协议版本”（旧版、Studio版、LwM2M、MQTT物联网套件等）并存的混乱情况。误区：最初依赖 AI 生成的代码和网络教程，使用的是通用的 MQTT 订阅方式。但实测发现，旧版 MQTT 协议（用于数据上报）的 Topic 通道并不支持新版 OTA 任务的下发通知。AI 提供的信息已过期，导致一直在错误的 API 路径上调试。

 **根本原因：** 
平台文档迭代导致的信息不对称。鉴权 (Token) 并非难点，难点在于找到正确的 OTA 任务查询接口 (HTTP API) 与 通知机制。

 **解决方案：** 
 **摒弃经验主义：** 放弃 AI 提供的过时代码，直接查阅 OneNET 官方最新 API 文档。

 **Postman 模拟验证：** 剥离 STM32，直接使用 Postman 工具构造 HTTP 请求。验证了 OTA 任务查询 URL：http://iot-api.heclouds.com/fuse-ota/...确认了必须使用 HTTP GET 主动轮询或特定的 MQTT 系统 Topic ($sys/...)。

 **协议固化：** 在 PC 端调通后，将验证成功的 Header 和 Payload 格式移植回 STM32 代码中，最终解决了“鉴权通过但无任务”的问题。

 **难点二：串口数据溢出 (UART Overrun Error)** 

 **问题描述：** OTA 传输开始后，通常在传输完第一包 (256字节) 后，STM32 停止响应，日志显示“传输中断”。

 **根本原因：**  **时序失配。** STM32 接收完数据后需要进行 Flash 擦写（耗时毫秒级），在此期间 CPU 无法处理串口中断。而 ESP32 发送速度极快，导致 STM32 硬件接收寄存器溢出 (ORE)，串口外设锁死。

 **解决方案：**  **启用 DMA (直接存储器访问)** 。配置 UART2_RX 为 DMA 模式，由 DMA 控制器直接将串口数据搬运至内存 ota_rx_buf，全过程不占用 CPU。实现“CPU 写 Flash”与“DMA 收数据”的并行处理，彻底根除溢出问题。

 **难点三：命令解析截断 (Size: 2 问题)** 

 **问题描述：** 引入 DMA 后，系统不再死机，但解析出的固件大小总是 2 字节（实际为 28560），导致 OTA 瞬间失败。

 **根本原因：**  **解析时机过早。** ESP32 发送 CMD_OTA_START:28560 时，STM32 的串口中断响应极快，在接收到第一个字符 2 时就触发了解析逻辑，导致 sscanf 截断了后续数字。

 **解决方案：** 修改串口中断回调函数 HAL_UART_RxCpltCallback。增加 结束符校验 (\n)：只有当接收缓冲区中检测到换行符时，才认为指令接收完整并执行 sscanf。

 **难点四：Flash 写入对齐与拼装** 

 **问题描述：** STM32F4 内部 Flash 要求 4 字节对齐写入，而网络数据包长度是不确定的，直接写入会导致 HardFault。

 **解决方案：** 设计  **双级缓冲机制** 。无论 DMA 收到多少字节，先存入 flash_cache_buf。只有当 Cache 凑满 256 字节（4 的倍数）时，才调用底层 HAL_FLASH_Program 接口。

 **4. 最终 OTA 通信协议摘要** 

为了确保稳定性，STM32 与 ESP 模组之间定义了严格的握手协议：

 **启动握手：** ESP -> STM32: CMD_OTA_START:<Size>\n
(STM32 校验参数，清空 DMA，擦除 Flash)
STM32 -> ESP: ACK_OK

 **数据流(循环)**  ：ESP -> STM32: [256 Bytes Binary Data] (由 DMA 自动接收)
(STM32 DMA 中断触发，校验长度，写入 Cache/Flash)
STM32 -> ESP: ACK_OK (通知 ESP 发送下一包)

 **结束** ：STM32 -> ESP: ACK_OK (写入 OTA 完成标志位，重启)

 **5. 项目总结** 
本项目成功将一个本地监控系统升级为具备工业级 OTA 能力的物联网终端。最大的收获在于：

 **调试方法的转变** ：在面对云平台文档混乱时，不再盲目试错，而是利用 Postman 等工具进行“黑盒探测”，确定边界条件后再写代码。

 **底层机制的理解** ：通过解决串口溢出问题，深刻理解了 RTOS 环境下 CPU 负载与外设中断之间的矛盾，掌握了 DMA 在高速数据传输中的核心作用。
